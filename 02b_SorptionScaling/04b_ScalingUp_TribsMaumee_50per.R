# JMH 23 Dec 2021
# Assuming colloid-P:DRP = 0.5, 
# combines water quality data for three tributaries and Maumee River and estimates: 
# (1) quantity of P sorption between tributary gaging station and Waterville, OH (Fig 2) 
# and (2) the P sorption upstream of Waterville, OH (Fig. 3). 
# Conducts bootstrapping for each tributary and Maumee River and exports the bootstrap results to a csv.

# Libraries ----
library(tidyverse)
library(zoo)
library(lubridate)

# Get data ----
## water quality & Q ----
# for target stream and downstream
# generated by code starting in 02
StartStumpf <- as.POSIXct("2019-03-01", format = "%Y-%m-%d")
EndStumpf <- as.POSIXct("2019-07-01", format = "%Y-%m-%d")

# Maumee River at Waterville for Maumee scaling
  wqMaum <- read.csv("04a_generatedDataOnGit/02d_MaumeeWatervilleWaterQual.csv", row.names = 1) %>% 
    mutate(Date = as.POSIXct(Date, format = "%Y-%m-%d", tz = "America/New_York"),
           SmpTimeWindowDay = 1) #daily data so window in days -=1
  
## sorption data ----
# generated by 04_SorptionData
SorpHF <- read.csv("04_generatedData/04d_SorpDat.csv", row.names =1) %>%
  filter(Percentile_flow >= 75)

SorpWC_Hf <- SorpHF %>%
              filter(Stream == "WC")
SorpSTF_Hf <- SorpHF %>%
              filter(Stream == "STF")
SorpUTLC_Hf <- SorpHF %>%
              filter(Stream == "UTLC")

# DRP-EPC0
ggplot(SorpHF, aes(y = AmbP_gPm3*0.5, x = EPC_gPm3)) +
  geom_point()+
  geom_abline(intercept = 0, slope = 1)

SorpHF2 <- SorpHF %>% 
  mutate(DRPmEPC = AmbP_gPm3 - EPC_gPm3,
         DRPmEPC_50 = AmbP_gPm3*0.5 - EPC_gPm3,
         DRPmEPC_25 = AmbP_gPm3*0.25 - EPC_gPm3,
         DRPmEPC_10 = AmbP_gPm3*0.1 - EPC_gPm3,
         DRPporEPC = AmbP_gPm3/EPC_gPm3,
         NotSorb_50 = as.factor(ifelse(DRPmEPC_50 < 0, "Desorb", "Sorb")),
         NotSorb_25 = as.factor(ifelse(DRPmEPC_25 < 0, "Desorb", "Sorb")),
         NotSorb_10 = as.factor(ifelse(DRPmEPC_10 < 0, "Desorb", "Sorb")))

## WQ data ----
# These are needed to redo this to evaluate various assumptions about the PO4/DRP ratio
# since these feed right into the bootstrap
wqUTLC2 <- read.csv(file.path(here::here("04a_generatedDataOnGit"),"04_WQandTT_UTLC.csv"), row.names = 1) %>% 
                    # assume that 50% of DRP is actually PO4 and can sorb
                    mutate(DRPgPm3 = DRPgPm3*0.5)
wqSTF2 <- read.csv(file.path(here::here("04a_generatedDataOnGit"),"04_WQandTT_STF.csv"), row.names = 1) %>% 
                    # assume that 50% of DRP is actually PO4 and can sorb
                    mutate(DRPgPm3 = DRPgPm3*0.5)
wqWC2 <- read.csv(file.path(here::here("04a_generatedDataOnGit"),"04_WQandTT_WC.csv"), row.names = 1) %>% 
                    # assume that 50% of DRP is actually PO4 and can sorb
                    mutate(DRPgPm3 = DRPgPm3*0.5)

# Scale and bootstrap Tribs ----
  ScalingFun <- function(WQdat, Sms_gPgDMmin.Med, Scap_gPgDM, StreamEPC, TimeWin){
    WQdat2 <- WQdat %>% 
      # potential ms sorption rate gP/gDM for the entire tt - needs MINS
      mutate(
        # potential ms sorption rate gP/gDM for the entire tt - needs MINS
        Sms_gPgDMtt.P = Sms_gPgDMmin.Med * tt_min.tot, #using tt_du here seems most reliable
        # final ms sorption rate gP/gDM for entire tt
        Sms_gPgDMtt.F = ifelse(Sms_gPgDMtt.P > Scap_gPgDM, Scap_gPgDM, Sms_gPgDMtt.P),
        # what percent of capacity?
        Sms_porCap = Sms_gPgDMtt.P/Scap_gPgDM,
        # potential volumetric sorption rate gP/m3/tt (w constraints on capacity)
        Svol_gPm3TT.P = Sms_gPgDMtt.F * SSgDMm3,
        # difference between DRP and EPC gP/m3
        DifDRP.EPC = ifelse((DRPgPm3 - StreamEPC)>0, DRPgPm3 - StreamEPC,0),
        # final volumetric sorption rate gP/m3/tt
        Svol_gPm3TT.F = ifelse(Svol_gPm3TT.P < DifDRP.EPC, Svol_gPm3TT.P, DifDRP.EPC),
        # potential volumetric sorption rate (w/o constraints on capacity or EPC)
        Svol_gPm3TT.P2 = Sms_gPgDMtt.P * SSgDMm3,
        # how far did the particle travel while sorbing
        # bit simplistic because it assumes velocity is same across reaches
        SorbDistM = Svol_gPm3TT.F/Svol_gPm3TT.P2 * segLg_M,
        # how much time did it take to saturate
        # again simplistic because it assumes velocity is same across reaches
        SorbTimeMin = Svol_gPm3TT.F/Svol_gPm3TT.P2 * tt_min.tot) %>% 
      # NOW THE SCALING
      # DRP moving DS during between samples gP/window
      mutate(DRPloadUS.gPwin = DRPgPm3 * Qm3m * TimeWin,
             # SS moving DS during window g DM/window
             SSloadUS.gDMwin = SSgDMm3 * Qm3m * TimeWin,
             # Vol sorption for all water in window gDM/window
             Svol_gPwindow = Svol_gPm3TT.F * Qm3m * TimeWin,
             # DRP load at DS site without sorption; gP/window
             DRPloadDS.gPwin.wS = DRPloadUS.gPwin + Svol_gPwindow,
             # portion of DRP sorbed
             porDRPloadSorbed = Svol_gPwindow/DRPloadUS.gPwin,
             # P sorbed/gSS in all water passing by station in a window
             gPsorb_gSS = Svol_gPwindow/SSloadUS.gDMwin,
             # putting parameters in final dataframe
             Sms_gPgDMmin.Med = Sms_gPgDMmin.Med,
             Scap_gPgDM = Scap_gPgDM,
             StreamEPC = StreamEPC)
    
    WQdat2
  }




ScalingBootFun <- function(
         SorpDatHF, 
         BootNum,
         WQdat, 
         TimeWin){

    # empty dataframe
  streamWQ_ibs <- as.data.frame(matrix(nrow = 1, ncol = 26))
  names(streamWQ_ibs) <- c("dateTime", "Qm3m", "SSgDMm3", "DRPgPm3", "gTarPerFlow", "tt_min.tot", "segLg_M", "Sms_gPgDMtt.P", "Sms_gPgDMtt.F",
                           "Sms_porCap", "Svol_gPm3TT.P", "DifDRP.EPC", "Svol_gPm3TT.F", "Svol_gPm3TT.P2", "SorbDistM", "SorbTimeMin", "DRPloadUS.gPwin" ,  
                           "SSloadUS.gDMwin", "Svol_gPwindow", "DRPloadDS.gPwin.wS", "porDRPloadSorbed", "gPsorb_gSS", "Sms_gPgDMmin.Med", 
                           "Scap_gPgDM", "StreamEPC", "bootN")
  
  # bootstrapping loop
  for(i in 1:BootNum) {
    # number of sorption measurements
    SorpSmpN <- seq(1,length(SorpDatHF$Sms_gPgDMmin))
    # random sample of mass specific sorption measurements with length of water quality data; units = gP/gDM/min
    Sms_gPgDMmin.Med_i = SorpDatHF$Sms_gPgDMmin[sample(SorpSmpN, size = dim(WQdat)[1], replace = TRUE)]
    # random sample of sorption capacity with length of water quality data; units = gP/gDM
    Scap_gPgDM_i = SorpDatHF$Scap_gPgDM[sample(SorpSmpN, size = dim(WQdat)[1], replace = TRUE)] 
    # random sample of EPC with length of water quality data; units = gP/m3
    StreamEPC_i = SorpDatHF$EPC_gPm3[sample(SorpSmpN, size = dim(WQdat)[1], replace = TRUE)]
    streamWQ2legnth <- dim(WQdat)[1]
    # function calculates travel time using Du equation
    # estimates volumetric sorption rate (gP/m3/tt) of entire travel time out of reach
    # Then, estimates sorption for the window
    streamWQ_i <- ScalingFun(WQdat, Sms_gPgDMmin.Med_i, Scap_gPgDM_i, StreamEPC_i, TimeWin) %>% 
      mutate(bootN = i)
    streamWQ_ibs <- rbind(streamWQ_ibs,streamWQ_i)
  }
  streamWQ_ibs
}


## Bootstrap tribs ----
### STF ----
    TribScalSTF <- ScalingBootFun(SorpDatHF = SorpSTF_Hf, 
                                    BootNum = 500,
                                    WQdat = wqSTF2, 
                                    TimeWin = 15)

### WC ----
    TribScalWC <- ScalingBootFun(SorpDatHF = SorpWC_Hf, 
                                    BootNum = 500,
                                    WQdat = wqWC2 , 
                                    TimeWin = 15)
  
  ### UTLC ----
    TribScalUTLC <- ScalingBootFun(SorpDatHF = SorpUTLC_Hf, 
                                    BootNum = 500,
                                    WQdat = wqUTLC2 , 
                                    TimeWin = 15)
  
## Save trib bootstraps ----
# takes a while
write.csv(TribScalSTF, file.path(here::here("04a_generatedDataTooBigForGit"), "04b_TribRawBootstrapResults_STF_50perDRP.csv"))
write.csv(TribScalWC, file.path(here::here("04a_generatedDataTooBigForGit"), "04b_TribRawBootstrapResults_WC_50perDRP.csv"))
write.csv(TribScalUTLC, file.path(here::here("04a_generatedDataTooBigForGit"), "04b_TribRawBootstrapResults_UTLC_50perDRP.csv"))

## Combine sorp estimates for Maumee ----
# Need a big vector of g P sorbed/ g SS
# This is every bootstraped estimate of gPsorbed/gSS - maximizing variation
# but restricting to high flow and to Mar-Jun


gPsrbGdmData <- rbind(TribScalSTF %>% 
                        mutate(stream = "STF"), 
                      TribScalWC %>% 
                        mutate(stream = "WC"), 
                      TribScalUTLC %>% 
                        mutate(stream = "UTLC")) %>%   
                  filter(gTarPerFlow == "Gtarget") %>% 
                  select(dateTime, gPsorb_gSS) %>% 
                  mutate(dateTime = as.POSIXct(dateTime, origin = "1970-01-01 00:00.00 UTC")) %>% 
                  filter(dateTime >= StartStumpf & dateTime <= EndStumpf)

# distribution of P sorption/gSS
# This is how much P is sorbed between the trib where this was measured and waterville.
# sorption saturated in all tribs.
hist(gPsrbGdmData$gPsorb_gSS)


# Scale & bootstrap Maumee ----
# took out TP from datasets because I didn't use it.
# 1 mg/L = 1 g/m3 so units on the concentrations work here

# Maumee River bootstrap function
MaumFun <- function(WQDat, gPsorbedgDMe){
  WQDat2 <- WQDat %>% 
    select(Date, SmpTimeWindowDay, Qm3day:gSRPday, SS_gm3:SRP_gm3, HighFlow) %>% #TP_mgL, 
    # estimate P sorbed
    mutate(gPsorbedgDM = gPsorbedgDMe,
           # this is potential, which can exceed DRP if not bounded
           gPsorbWindowP = gPsorbedgDM * gSSday,
           # bound sorption to available P
           # conservative since we argue that DRP upstream was higher
           # NOT USING THIS HERE
           gPsorbWindow = ifelse(gPsorbWindowP > gSRPday, gSRPday, gPsorbWindowP),
           # estimate DRP load - observed + sorbed)
           gDRPwindowWOsorpP = gSRPday + gPsorbWindowP,
           gDRPwindowWOsorp = gSRPday + gPsorbWindow)
  
  WQDat2
}

## Maumee bootstrap ----
# number of draws
BootNum <- 500

# empty dataframe
streamWQ_MW <- as.data.frame(matrix(nrow = 1, ncol = 13)) %>% 
  mutate(bootN = as.numeric("NA"))

names(streamWQ_MW) <- c("Date", "SmpTimeWindowDay", "Qm3day", "gSSday", "gSRPday",
                        "SS_gm3", "SRP_gm3", "HighFlow", "gPsorbedgDM", "gPsorbWindowP", "gPsorbWindow", "gDRPwindowWOsorpP", "gDRPwindowWOsorp", "bootN")


# bootstrap
for(i in 1:BootNum) {
  # i = 1
  SorpSmpN <- seq(1,length(gPsrbGdmData$gPsorb_gSS))
  gPsorbedgDMe_i = gPsrbGdmData$gPsorb_gSS[sample(SorpSmpN, size = dim(wqMaum)[1], replace = TRUE)]
  streamWQ_i <-  MaumFun(WQDat = wqMaum,
                         gPsorbedgDMe = gPsorbedgDMe_i) %>%
    mutate(bootN = i)
  streamWQ_MW <- rbind(streamWQ_MW, streamWQ_i)
}

streamWQ_MW2 <- streamWQ_MW[-1,]


## Export Maumee scale dat ----
# write.csv(streamWQ_MW, file.path(here::here("04a_generatedDataTooBigForGit"), "04b_RawBootstrapResults_Maumee_50perDRP.csv"))


# save/load ----
# save.image(file.path(here::here("03_Rdata"),"06c_ScalingSorption2TribMaumee_50perDRP_Rdata"))
# load(file.path(here::here("03_Rdata"),"06c_ScalingSorption2TribMaumee_50perDRP_Rdata"))















